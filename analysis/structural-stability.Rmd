---
title: "Bayesian MAR(1) models and structural stability"
author: "Matthew A. Barbour"
date: "`r Sys.Date()`"
output: workflowr::wflow_html
editor_options:
  chunk_output_type: console
---

```{r setup, include=FALSE}
# set knitr options
knitr::opts_chunk$set(autodep = TRUE, message = FALSE)

# load required libraries:
library(RCurl)
library(brms)
library(tidyverse)
library(cowplot)
library(matlib) # for calculating matrix inverse
library(tidybayes)
library(knitr)
library(rgl)

# these options help Stan run faster:
rstan::rstan_options(auto_write = TRUE)
options(mc.cores = parallel::detectCores())

# set ggplot theme
theme_set(theme_cowplot())

# for interactive rgl plot
knit_hooks$set(webgl = hook_webgl)
```


# Setup

```{r load-time-series}
# load data
timeseries_df <- read_csv("output/timeseries_df.csv") %>%
  mutate(# this makes the intercept correspond to rich = 1, rather
         # than the biologically implausible rich = 0
         rich = rich - 1,
         # now rich and temp coefficients will correspond to +1 genotype and +1 C
         temp = ifelse(temp == "20 C", 0, 3),
         uniq = paste(Cage, temp, com, Week_match, sep = "-"),
         Week_match.1p = 1 + Week_match) # analysis doesn't like initial Week_match = 0, so I just added 1

# filter dataset for multivariate analysis.
# I only retain data for which all species had positive abundances at the previous time step
full_df <- filter(timeseries_df, BRBR_t > 0, LYER_t > 0, Ptoid_t > 0) 
```

```{r}
## source in useful functions

# functions for plotting feasibility domains and calculating normalized angles from critical boundary
source("code/plot-feasibility-domain.R") 
# functions for non-equilibrium simulation
source("code/simulate-community-dynamics.R")
```


# Full model

This model corresponds to equation 1 in the Supplementary Material of the paper. Note that `BRBR` = aphid *Brevicoryne brassicae*, `LYER` = aphid *Lipaphis erysimi*, and `Ptoid` = parasitoid *Diaeretiella rapae*.

```{r full-mv-norm-formulas}
# BRBR
full.mv.norm.BRBR.bf <- bf(log1p(BRBR_t1) ~ 
                       0 + intercept + offset(log1p(BRBR_t)) + 
                        (log1p(BRBR_t) + log1p(LYER_t) + log1p(Ptoid_t))*(temp + rich) +
                        log(Biomass_g_t1) +
                        (1 | Cage) +
                        ar(time = Week_match.1p, gr = Cage, p = 1, cov = FALSE))

# LYER
full.mv.norm.LYER.bf <- bf(log1p(LYER_t1) ~ 
                       0 + intercept + offset(log1p(LYER_t)) + 
                        (log1p(BRBR_t) + log1p(LYER_t) + log1p(Ptoid_t))*(temp + rich) +
                        log(Biomass_g_t1) +
                        (1 | Cage) +
                        ar(time = Week_match.1p, gr = Cage, p = 1, cov = FALSE))

# Ptoid
full.mv.norm.Ptoid.bf <- bf(log1p(Ptoid_t1) ~ 
                       0 + intercept + offset(log1p(Ptoid_t)) + 
                        (log1p(BRBR_t) + log1p(LYER_t) + log1p(Ptoid_t))*(temp + rich) +
                        log(Biomass_g_t1) +
                        (1 | Cage) +
                        ar(time = Week_match.1p, gr = Cage, p = 1, cov = FALSE))
```


## Set priors

### Intrinsic growth rates

```{r r-priors}
# from Jahan et al. 2014, Journal of Insect Science
# Table 4 lambda (finite rate of increase, discrete time analogue of intrinsic growth rate)
# calculated on a per-day basis and not logged. This is why I multiply by 7 and then take the natural logarithm
Jahan.r.BRBR <- log(c(1.42, 1.36, 1.32, 1.35, 1.40, 1.33, 1.38, 1.37) * 7)
mean(Jahan.r.BRBR) # 2.26
sd(Jahan.r.BRBR) # 0.02
# visualize prior
hist(rnorm(1000, mean(Jahan.r.BRBR), sd = 1))
prior.r.BRBR <- "normal(2.26, 1)"

# from Taghizadeh 2019, J. Agr. Sci. Tech.
# Table 2 lambda (finite rate of increase, discrete time analogue of intrinsic growth rate)
# calculated on a per-day basis and not logged. This is why I multiply by 7 and then take the natural logarithm
Tag.r.LYER <- log(c(1.35, 1.30, 1.26, 1.23) * 7)
mean(Tag.r.LYER) # 2.20
sd(Tag.r.LYER) # 0.04
# visualize prior
hist(rnorm(1000, mean(Tag.r.LYER), sd = 1))
prior.r.LYER <- "normal(2.20, 1)"

# random effects prior based on variance among cultivars
# I'm just going to use this for all of them
mean.r.sd <- mean(c(sd(Jahan.r.BRBR), sd(Tag.r.LYER)))
# visualize prior
hist(rnorm(1000, mean = mean.r.sd, sd = 0.5))
prior.random.effects <- "normal(0.03, 0.5)"

# I don't have a great sense for the growth rate of the parasitoid, other than that it should be negative
# this seems like a reasonable starting point

# visualize prior
hist(rnorm(1000, mean = -1.5, sd = 1))
prior.r.Ptoid <- "normal(-1.5, 1)"
```

### Intra- and interspecific interactions

I assume they are weak, i.e. much less than $|1|$. I also assume that all species exhibit intraspecific competition, aphids have negative interspecific effects with each other, but positive interspecific effects on the parasitoid. I also assume parasitoids have negative interspecific effects on the aphids.

```{r interaction-priors}
## intraspecific, 0 = no density dependence. this occurs because of offset in model.
# visualize prior
hist(rnorm(1000, mean = -0.1, sd = 0.5))
prior.intra.BRBR <- "normal(-0.1, 0.5)"
prior.intra.LYER <- "normal(-0.1, 0.5)"
prior.intra.Ptoid <- "normal(-0.1, 0.5)"

## negative interspecific, 0 = no interaction
# visualize prior
hist(rnorm(1000, mean = -0.1, sd = 0.5))
# most of these values are less than 1, which
# is indicative of saturating effects
prior.LYERonBRBR <- "normal(-0.1, 0.5)" 
prior.PtoidonBRBR <- "normal(-0.1, 0.5)"
prior.BRBRonLYER <- "normal(-0.1, 0.5)"
prior.PtoidonLYER <- "normal(-0.1, 0.5)"

## positive interspecific
# visualize prior
hist(rnorm(1000, mean = 0.1, sd = 0.5))
# most of these values are less than 1, which
# is indicative of saturating effects
prior.BRBRonPtoid <- "normal(0.1, 0.5)"
prior.LYERonPtoid <- "normal(0.1, 0.5)"
```

### Genetic richness and genotype effects

It was unclear to me *a priori* exactly how genetic diversity and specific genotypes would affect species' growth rates or intra- and interspecific interactions. Therefore, I assumed these effects on specific rates could be positive or negative, but would likely be between -1 and 1 (i.e., not ridiculously large).

```{r rich-priors}
prior.rich <- "normal(0, 0.5)"
```

I used `prior.rich` as the prior for genotype-specific effects as well.

### Temperature effects

```{r temp-priors}
prior.temp <- "normal(0, 0.5)"
```

### Biomass effects

For both aphids, I thought that increasing biomass would increase their intrinsic growth rates, but only weakly, because I didn't expect biomass to be limiting. 

```{r aphid-biomass-priors}
# visualize prior
hist(rnorm(1000, mean = 0.1, sd = 0.5))
prior.AphidBiomass <- "normal(0.1, 0.5)"
```

For the parasitoid, it was unclear to me whether increasing biomass would have positive or negative effects. I could imagine both, as increasing biomass may increase the search effort of parasitoids, resulting in a negative effect on their growth rate. Alternatively, more biomass may increase the quality of aphids, which could increase the parasitoid's growth rate. Therefore, I specified a normal prior with mean = 0 and SD = 0.5, so that most of the distribution lied between -1 and 1 (i.e. saturating negative or positive effects).

```{r ptoid-biomass-prior}
# visualize prior
hist(rnorm(1000, mean = 0, sd = 0.5))
prior.PtoidBiomass <- "normal(0, 0.5)"
```

## Analysis

I first fit a complete model with rich and temperature effects

```{r full-mv-norm-brm}
full.mv.norm.brm <- brm(
  data = full_df,
  formula = mvbf(full.mv.norm.BRBR.bf, full.mv.norm.LYER.bf, full.mv.norm.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.BRBR, class = "b", coef = "log1pBRBR_t", resp = "log1pBRBRt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pPtoid_t", resp = "log1pPtoidt1"),
            # negative interspecific effects
            set_prior(prior.LYERonBRBR, class = "b", coef = "log1pLYER_t", resp = "log1pBRBRt1"),
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # rich effects
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pBRBRt1"),
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pPtoidt1"),  
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pBRBRt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pLYER_t:rich", resp = "log1pBRBRt1"),
            set_prior(prior.rich, class = "b", coef = "log1pLYER_t:rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pLYER_t:rich", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pPtoid_t:rich", resp = "log1pBRBRt1"),
            set_prior(prior.rich, class = "b", coef = "log1pPtoid_t:rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pPtoid_t:rich", resp = "log1pPtoidt1"),
            # temp effects
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pLYERt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pPtoidt1"),  
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pLYERt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pLYER_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pLYER_t:temp", resp = "log1pLYERt1"),
            set_prior(prior.temp, class = "b", coef = "log1pLYER_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pLYERt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pPtoidt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pBRBRt1"),
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/full.mv.norm.brm.rds") 

# print summary
summary(full.mv.norm.brm)
```

## Inspect credible intervals

Below, I inspect which parameters may be safely omitted from the model. It seemed reasonable that if 80% of the posterior probability distribution of the parameter included zero, then I could safely drop it from the model. Therefore, I proceeded with this criteria, starting with the highest-order terms:

```{r full-mv-norm-highest-order}
# higher-order temperature effects
bayesplot::mcmc_intervals(full.mv.norm.brm, regex_pars = "_t:temp$", prob = 0.80, prob_outer = 0.95) # drop LYER:temp effect on BRBR; all Species:temp effects on LYER; and (LYER and Ptoid):temp effects on Ptoid

# higher-order rich effects
bayesplot::mcmc_intervals(full.mv.norm.brm, regex_pars = "_t:rich$", prob = 0.80, prob_outer = 0.95) # drop all Species:rich effect on BRBR; drop (LYER and Ptoid):rich effects on LYER; drop Ptoid:rich effect on Ptoid
```

# Model selection

## Reduced model 1

### Drop terms

Based on the above plots, I dropped the following higher-order terms:

Effects on **BRBR_t1**:

- `(log1p(LYER_t) + log1p(BRBR_t) + log1p(Ptoid_t)):rich`
- `log1p(LYER_t):temp`

Effects on **LYER_t1**:

- `(log1p(LYER_t) + log1p(BRBR_t) + log1p(Ptoid_t)):temp`
- `(log1p(LYER_t) + log1p(Ptoid_t)):rich`

Effects on **Ptoid_t1**

- `(log1p(LYER_t) + log1p(Ptoid_t)):temp`
- `log1p(Ptoid_t):rich`

### Refit model

```{r reduced-1-brm}
# update formulas
reduced.1.BRBR.bf <- update(full.mv.norm.BRBR.bf, .~. -(log1p(LYER_t) + log1p(BRBR_t) + log1p(Ptoid_t)):rich -log1p(LYER_t):temp)
reduced.1.LYER.bf <- update(full.mv.norm.LYER.bf, .~. -(log1p(LYER_t) + log1p(BRBR_t) + log1p(Ptoid_t)):temp -(log1p(LYER_t) + log1p(Ptoid_t)):rich)
reduced.1.Ptoid.bf <- update(full.mv.norm.Ptoid.bf, .~. -(log1p(LYER_t) + log1p(Ptoid_t)):temp -log1p(Ptoid_t):rich)

# fit update model
reduced.1.brm <- brm(
  data = full_df,
  formula = mvbf(reduced.1.BRBR.bf, reduced.1.LYER.bf, reduced.1.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.BRBR, class = "b", coef = "log1pBRBR_t", resp = "log1pBRBRt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pPtoid_t", resp = "log1pPtoidt1"),
            # negative interspecific effects
            set_prior(prior.LYERonBRBR, class = "b", coef = "log1pLYER_t", resp = "log1pBRBRt1"),
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # rich effects
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pBRBRt1"),
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pPtoidt1"),  
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pLYER_t:rich", resp = "log1pPtoidt1"),
            # temp effects
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pLYERt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pPtoidt1"),  
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pBRBRt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pBRBRt1"),
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/reduced.1.brm.rds") 

# print model summary
summary(reduced.1.brm)
```

### Inspect credible intervals

```{r reduced-1-summary}
# check highest-order temp effects
bayesplot::mcmc_intervals(reduced.1.brm, regex_pars = ":temp$", prob = 0.80, prob_outer = 0.95) # retain all

# check main temp effect
bayesplot::mcmc_intervals(reduced.1.brm, regex_pars = "_temp$", prob = 0.80, prob_outer = 0.95) # drop temp effect on LYER

# check highest-order rich effects
bayesplot::mcmc_intervals(reduced.1.brm, regex_pars = ":rich$", prob = 0.80, prob_outer = 0.95) # retain all

# check main rich effect
bayesplot::mcmc_intervals(reduced.1.brm, regex_pars = "_rich$", prob = 0.80, prob_outer = 0.95) # drop rich effect on BRBR, keep others to preserve marginality in higher-order terms

# check biomass effects
bayesplot::mcmc_intervals(reduced.1.brm, regex_pars = "logBiomass_g_t1$", prob = 0.80, prob_outer = 0.95) # drop biomass effect on BRBR

## check interactions (at 20 C in average monoculture)
# BRBR effect
bayesplot::mcmc_intervals(reduced.1.brm, regex_pars = "_log1pBRBR_t$", prob = 0.80, prob_outer = 0.95) # note that I keep intraspecific BRBR effects to preserve marginality with higher-order BRBR:temp effect on BRBR.
# LYER effect
bayesplot::mcmc_intervals(reduced.1.brm, regex_pars = "_log1pLYER_t$", prob = 0.80, prob_outer = 0.95) # drop LYER effect on BRBR
# Ptoid effect
bayesplot::mcmc_intervals(reduced.1.brm, regex_pars = "_log1pPtoid_t$", prob = 0.80, prob_outer = 0.95) # drop Ptoid effect on itself
```


## Reduced model 2

### Drop terms

Based on the above plots, I dropped the following terms:

Effects on **BRBR_t1**:

- `rich`
- `log1p(LYER_t)`
- `log(Biomass_g_t1)`

Effects on **LYER_t1**:

- `temp`

Effects on **Ptoid_t1**:

- `log1p(Ptoid_t)`

### Refit model

```{r reduced-2-brm}
# update formulas
reduced.2.BRBR.bf <- update(reduced.1.BRBR.bf, .~. -rich -log1p(LYER_t) -log(Biomass_g_t1))
reduced.2.LYER.bf <- update(reduced.1.LYER.bf, .~. -temp)
reduced.2.Ptoid.bf <- update(reduced.1.Ptoid.bf, .~. -log1p(Ptoid_t))

# fit new model
reduced.2.brm <- brm(
  data = full_df,
  formula = mvbf(reduced.2.BRBR.bf, reduced.2.LYER.bf, reduced.2.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.BRBR, class = "b", coef = "log1pBRBR_t", resp = "log1pBRBRt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            # negative interspecific effects
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # rich effects
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pPtoidt1"),  
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pLYER_t:rich", resp = "log1pPtoidt1"),
            # temp effects
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pPtoidt1"),  
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pBRBRt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/reduced.2.brm.rds") 

# print model summary
summary(reduced.2.brm)
```

### Inspect credible intervals

```{r reduced-2-summary}
# check highest-order temp effects
bayesplot::mcmc_intervals(reduced.2.brm, regex_pars = "_t:temp$", prob = 0.80, prob_outer = 0.95)

# check temp effects on growth rates
bayesplot::mcmc_intervals(reduced.2.brm, regex_pars = "_temp$", prob = 0.80, prob_outer = 0.95)

# check highest-order rich effects
bayesplot::mcmc_intervals(reduced.2.brm, regex_pars = "_t:rich$", prob = 0.80, prob_outer = 0.95) # all remaining higher-order rich effects have 95% credible intervals that overlap zero

# check rich effects on growth rates
bayesplot::mcmc_intervals(reduced.2.brm, regex_pars = "_rich$", prob = 0.80, prob_outer = 0.95) # note that I keep rich effect on Ptoid to preserve marginality with higher-order rich effect

# check biomass effects
bayesplot::mcmc_intervals(reduced.2.brm, regex_pars = "logBiomass_g_t1$", prob = 0.80, prob_outer = 0.95)

# check intrinsic growth rates (at 20 C in average monoculture)
bayesplot::mcmc_intervals(reduced.2.brm, regex_pars = "intercept$", prob = 0.80, prob_outer = 0.95)

# check interactions (at 20 C in average monoculture)
bayesplot::mcmc_intervals(reduced.2.brm, regex_pars = "_log1pBRBR_t$", prob = 0.80, prob_outer = 0.95) # note that I keep intraspecific BRBR effects to preserve marginality with higher-order BRBR:temp effect on itself.
bayesplot::mcmc_intervals(reduced.2.brm, regex_pars = "_log1pLYER_t$", prob = 0.80, prob_outer = 0.95)
bayesplot::mcmc_intervals(reduced.2.brm, regex_pars = "_log1pPtoid_t$", prob = 0.80, prob_outer = 0.95)
```

Now, all higher-order terms have 80% credible intervals that do not overlap zero. 

## Reduced model 3

### Drop terms

It is unclear how to progress now, although there are a few terms with less clear effects (still above 80% criteria used previously), including:

Effects on **LYER_t1**:

- `log1p(BRBR_t):rich`

Effects on **Ptoid_t1**:

- `log1p(LYER_t):rich`
- `log1p(BRBR_t):rich`

I'm going to try dropping `log1p(LYER_t):rich` from the previous model. 

### Refit model

```{r reduced-3-brm}
# update formulas
reduced.3.BRBR.bf <- reduced.2.BRBR.bf
reduced.3.LYER.bf <- reduced.2.LYER.bf
reduced.3.Ptoid.bf <- update(reduced.2.Ptoid.bf, .~. -log1p(LYER_t):rich)

# fit new model
reduced.3.brm <- brm(
  data = full_df,
  formula = mvbf(reduced.3.BRBR.bf, reduced.3.LYER.bf, reduced.3.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.BRBR, class = "b", coef = "log1pBRBR_t", resp = "log1pBRBRt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            # negative interspecific effects
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # rich effects
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pPtoidt1"),
            # temp effects
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pPtoidt1"),  
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pBRBRt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/reduced.3.brm.rds") 

# print model summary
summary(reduced.3.brm)
```

### Inspect credible intervals

Note that this is the final model used to assess the structural stability of the initial food web and the dominant food chain, so I illustrate the credible intervals of its modelled parameters.

```{r reduced-3-summary}
# check highest-order temp effects
bayesplot::mcmc_intervals(reduced.3.brm, regex_pars = "_t:temp$", prob = 0.80, prob_outer = 0.95)

# check highest-order rich effects
bayesplot::mcmc_intervals(reduced.3.brm, regex_pars = "_t:rich$", prob = 0.80, prob_outer = 0.95) # higher-order BRBR:rich effect on Ptoid no longer meets 80% cutoff.

# check temp effects on growth rates
bayesplot::mcmc_intervals(reduced.3.brm, regex_pars = "_temp$", prob = 0.80, prob_outer = 0.95)

# check rich effects on growth rates
bayesplot::mcmc_intervals(reduced.3.brm, regex_pars = "_rich$", prob = 0.80, prob_outer = 0.95)

# check biomass effects
bayesplot::mcmc_intervals(reduced.3.brm, regex_pars = "logBiomass_g_t1$", prob = 0.80, prob_outer = 0.95)

# check intrinsic growth rates (at 20 C in average monoculture)
bayesplot::mcmc_intervals(reduced.3.brm, regex_pars = "intercept$", prob = 0.80, prob_outer = 0.95)

# check interactions (at 20 C in average monoculture)
bayesplot::mcmc_intervals(reduced.3.brm, regex_pars = "_log1pBRBR_t$", prob = 0.80, prob_outer = 0.95)
bayesplot::mcmc_intervals(reduced.3.brm, regex_pars = "_log1pLYER_t$", prob = 0.80, prob_outer = 0.95)
bayesplot::mcmc_intervals(reduced.3.brm, regex_pars = "_log1pPtoid_t$", prob = 0.80, prob_outer = 0.95)
```

## Reduced model 4

### Drop terms

Now try dropping `log1p(BRBR_t):rich` effect on **Ptoid_t1** instead.

### Refit model

```{r reduced-4-brm}
# update formulas
# note that I'm updating model 2, not model 3
reduced.4.BRBR.bf <- reduced.2.BRBR.bf
reduced.4.LYER.bf <- reduced.2.LYER.bf
reduced.4.Ptoid.bf <- update(reduced.2.Ptoid.bf, .~. -log1p(BRBR_t):rich)

# fit new model
reduced.4.brm <- brm(
  data = full_df,
  formula = mvbf(reduced.4.BRBR.bf, reduced.4.LYER.bf, reduced.4.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.BRBR, class = "b", coef = "log1pBRBR_t", resp = "log1pBRBRt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            # negative interspecific effects
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # rich effects
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pLYER_t:rich", resp = "log1pPtoidt1"),
            # temp effects
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pPtoidt1"),  
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pBRBRt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/reduced.4.brm.rds") 

# print model summary
summary(reduced.4.brm)
```

### Inspect credible intervals

```{r reduced-4-summary}
# check highest-order rich effects
bayesplot::mcmc_intervals(reduced.4.brm, regex_pars = "_t:rich$", prob = 0.80, prob_outer = 0.95) # higher-order LYER:rich effect on Ptoid no longer meets 80% cutoff.
```

## Reduced model 5

### Drop terms

For both reduced model 3 and 4, once I drop the higher-order interaction with `rich`, the other higher-order term doesn't meet the 80% interval cutoff, so I will try dropping both from the model.

After dropping this term, it also appears that `rich` effect on Ptoid intrinsic growth rate is no longer needed (80% interval criterion, model not shown), so I will drop that now too.

This model effectively removes all of the `rich` effects on **Ptoid_t1**.

### Refit model

```{r reduced-5-brm}
# update formulas
# note that I'm updating model 2
reduced.5.BRBR.bf <- reduced.2.BRBR.bf
reduced.5.LYER.bf <- reduced.2.LYER.bf
reduced.5.Ptoid.bf <- update(reduced.2.Ptoid.bf, .~. -log1p(BRBR_t):rich -log1p(LYER_t):rich -rich)

# fit new model
reduced.5.brm <- brm(
  data = full_df,
  formula = mvbf(reduced.5.BRBR.bf, reduced.5.LYER.bf, reduced.5.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.BRBR, class = "b", coef = "log1pBRBR_t", resp = "log1pBRBRt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            # negative interspecific effects
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # rich effects
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pLYERt1"),
            # temp effects
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pPtoidt1"),  
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pBRBRt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/reduced.5.brm.rds") 

# print model summary
summary(reduced.5.brm)
```

## Reduced model 6

### Drop terms

Try dropping `log1p(BRBR_t):rich` effect on **LYER_t1** instead of `rich` effects on **Ptoid_t1**. I also drop main effect of `rich` on **LYER_t1**, because its 80% interval overlapped with zero after removing `log1p(BRBR_t):rich` (not shown).

### Refit model

```{r reduced-6-brm}
# update formulas
# note that I'm updating model 2
reduced.6.BRBR.bf <- reduced.2.BRBR.bf
reduced.6.LYER.bf <- update(reduced.2.LYER.bf, .~. -log1p(BRBR_t):rich -rich)
reduced.6.Ptoid.bf <- reduced.2.Ptoid.bf

# fit new model
reduced.6.brm <- brm(
  data = full_df,
  formula = mvbf(reduced.6.BRBR.bf, reduced.6.LYER.bf, reduced.6.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.BRBR, class = "b", coef = "log1pBRBR_t", resp = "log1pBRBRt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            # negative interspecific effects
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # rich effects
            set_prior(prior.rich, class = "b", coef = "rich", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:rich", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pLYER_t:rich", resp = "log1pPtoidt1"),
            # temp effects
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pPtoidt1"),  
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pBRBRt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/reduced.6.brm.rds") 

# print model summary
summary(reduced.6.brm)
```

## Reduced model 7

### Drop terms

Drop all `rich` effects, but keep `temp` effects (for all of which their 95% posterior estimates are different from zero.)

### Refit model

```{r reduced-7-brm}
# update formulas
reduced.7.BRBR.bf <- reduced.2.BRBR.bf
reduced.7.LYER.bf <- reduced.6.LYER.bf
reduced.7.Ptoid.bf <- reduced.5.Ptoid.bf

# fit new model
reduced.7.brm <- brm(
  data = full_df,
  formula = mvbf(reduced.7.BRBR.bf, reduced.7.LYER.bf, reduced.7.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.BRBR, class = "b", coef = "log1pBRBR_t", resp = "log1pBRBRt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            # negative interspecific effects
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # temp effects
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pPtoidt1"),  
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pBRBRt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/reduced.7.brm.rds") 

# print model summary
summary(reduced.7.brm)
```

## Reduced model 8

### Drop terms

Drop all `temp` effects now even though most of their 95% posterior estimates are different from zero in the previous models. This will serve as a baseline model without any treatment effects. I expect this to be the worst model.

I also dropped `log1p(BRBR_t)` effect on **BRBR_t1** because it no longer had a widely overlapping confidence interval with zero (not shown).

### Refit model

```{r reduced-8-brm}
# update formulas
# note that I'm updating model 2 for BRBR and model 5 for the Ptoid
reduced.8.BRBR.bf <- update(reduced.2.BRBR.bf, .~. -log1p(BRBR_t):temp -log1p(Ptoid_t):temp -temp -log1p(BRBR_t))
reduced.8.LYER.bf <- reduced.6.LYER.bf # no temp effects anyway 
reduced.8.Ptoid.bf <- update(reduced.5.Ptoid.bf, .~. -log1p(BRBR_t):temp -temp)

# fit new model
reduced.8.brm <- brm(
  data = full_df,
  formula = mvbf(reduced.8.BRBR.bf, reduced.8.LYER.bf, reduced.8.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            # negative interspecific effects
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/reduced.8.brm.rds") 

# print model summary
summary(reduced.8.brm)
```

### Inspect credible intervals

Only `log(Biomass_g_t1)` effect on LYER has a 95% posterior interval that includes zero (80% interval doesn't though). See also summary of model above.

```{r reduced-8-summary}
# check biomass effects
bayesplot::mcmc_intervals(reduced.8.brm, regex_pars = "logBiomass_g_t1$", prob = 0.80, prob_outer = 0.95)
```


## Model comparison

```{r model-comparsion}
# add leave-one-out (loo) cross-validation criterion to each model
full.mv.norm.brm <- add_criterion(full.mv.norm.brm, criterion = "loo", force_save = T, reloo = T)
# reduced.1.brm # intermediate model on way to determine 80% cutoff, I so don't use it for comparison
reduced.2.brm <- add_criterion(reduced.2.brm, criterion = "loo", force_save = T, reloo = T) 
reduced.3.brm <- add_criterion(reduced.3.brm, criterion = "loo", force_save = T, reloo = T) 
reduced.4.brm <- add_criterion(reduced.4.brm, criterion = "loo", force_save = T, reloo = T) 
reduced.5.brm <- add_criterion(reduced.5.brm, criterion = "loo", force_save = T, reloo = T)
reduced.6.brm <- add_criterion(reduced.6.brm, criterion = "loo", force_save = T, reloo = T) 
reduced.7.brm <- add_criterion(reduced.7.brm, criterion = "loo", force_save = T) # reloo not needed
reduced.8.brm <- add_criterion(reduced.8.brm, criterion = "loo", force_save = T, reloo = T) 

# compare models
loo_compare(full.mv.norm.brm, # full model
            #reduced.1.brm, # intermediate model on way to determine 80% cutoff
            reduced.2.brm, # all parameters have >80% of their posterior estimates different from zero
            reduced.3.brm, # drop log1p(LYER_t):rich on Ptoid from 80% PP cutoff model
            reduced.4.brm, # drop log1p(BRBR_t):rich on Ptoid from 80% PP cutoff model
            reduced.5.brm, # drop all rich effects on Ptoid from 80% PP cutoff model
            reduced.6.brm, # drop all rich effects on LYER from 80% PP cutoff model
            reduced.7.brm, # drop all rich effects from 80% PP cutoff model
            reduced.8.brm, # drop all rich and temp effects from 80% PP cutoff model
            criterion = "loo",
            model_names = c("Full","80% PP cutoff","Drop LYER:rich for Ptoid","Drop BRBR:rich for Ptoid","Drop all rich for Ptoid","Drop all rich for LYER","Drop all rich effects","Drop all rich and temp effects"))
```

As you can see, there are several models that provide similar fits to data for the initial food web (i.e., the standard error of the model fit overlaps with the top model). Of these models, however, only `reduced.3.brm` (i.e., "Drop LYER:rich for Ptoid") was able to reproduce our observed genotype-specific effects on critical transitions in the dominant food chain (see [Genotypic effects](#genotypic-effects)). Therefore, I used `reduced.3.brm` to assess the [Structural stability of dominant food chain](#structural-stability-of-dominant-food-chain) and [Structural stability of initial food web](#structural-stability-of-initial-food-web).

# Structural stability of dominant food chain

```{r}
# specify the model for subsequent analysis
rich_model <- reduced.3.brm
```

## Reproduce Fig. 4

Since our observational data indicated clear effects of genetic diversity on the persistence of the LYER-Ptoid subcommunity, I restrict our subsequent analysis to this effect (i.e. no temperature).

Remember that I set rich = 1 as the zero point for this model. Therefore, the intercept in the model corresponds to when rich = 1, and the effect of rich corresponds to a unit increase in rich (i.e., rich = 2).

Note that I did not specify an effect of richness on the intra- or interspecific interactions in LYER or Ptoid. Therefore, the interaction matrix is the same for all levels of richness.

Also, I did this comparison at an imaginary midpoint of temperature, i.e. `temp = 1.5`. In this food chain, temperature only had a clear effect on the parasitoid's intrinsic growth rate, so I only add the temperature effect here.


```{r rich-mean-estimates}
coef.rich <- fixef(rich_model)[,"Estimate"]

# value of rich to condition
temp.cond <- 1.5 # 1.5 = 21.5 C
# I chose 1.5 to condition on
# an imaginary average between temperature treatments
# note that setting it to zero, represents temp = 20 C

# interaction matrix for all levels of rich
rich1.mat <- matrix(c(coef.rich["log1pLYERt1_log1pLYER_t"], 
                      coef.rich["log1pLYERt1_log1pPtoid_t"],
                      coef.rich["log1pPtoidt1_log1pLYER_t"], 
                      0), # set to zero because there was no clear evidence for intraspecific Ptoid effect
                    ncol = 2, byrow = TRUE)
rich1.mat
rich2.mat <- rich1.mat
rich4.mat <- rich1.mat

# growth rates when rich = 1
rich1.IGR <- matrix(c(coef.rich["log1pLYERt1_intercept"],
                      coef.rich["log1pPtoidt1_intercept"] + coef.rich["log1pPtoidt1_temp"]*temp.cond),
                    ncol = 1)
rich1.IGR

# growth rates when rich = 2
rich2.IGR <- matrix(c(coef.rich["log1pLYERt1_intercept"] + coef.rich["log1pLYERt1_rich"],
                      coef.rich["log1pPtoidt1_intercept"] + coef.rich["log1pPtoidt1_rich"] + coef.rich["log1pPtoidt1_temp"]*temp.cond), 
                    ncol = 1)
rich2.IGR

# growth rates when rich = 4
rich4.IGR <- matrix(c(coef.rich["log1pLYERt1_intercept"] + coef.rich["log1pLYERt1_rich"]*3,
                      coef.rich["log1pPtoidt1_intercept"] + coef.rich["log1pPtoidt1_rich"]*3 + coef.rich["log1pPtoidt1_temp"]*temp.cond), 
                    ncol = 1)
rich4.IGR
```

Plot the effect of genetic diversity on structural stability.

```{r rich-feasibility-domain}
# get raw data for manually making plot
get_FD.2sp <- FeasibilityDomain2sp(A = list(rich1.mat, rich2.mat, rich4.mat),
                     r = list(rich1.IGR, rich2.IGR, rich4.IGR),
                     labels = c("1", "2", "4"),
                     normalize = TRUE) %>%
  rename(rich = A_ID) 

# Draw polygon for feasibility domain
# from: https://stackoverflow.com/questions/12794596/how-fill-part-of-a-circle-using-ggplot2
# define the circle; add a point at the center if the 'pie slice' if the shape is to be filled
circleFun <- function(center=c(0,0), diameter=1, npoints=100, start=0, end=2, filled=TRUE){
  tt <- seq(start*pi, end*pi, length.out=npoints)
  df <- data.frame(
    x = center[1] + diameter / 2 * cos(tt),
    y = center[2] + diameter / 2 * sin(tt)
  )
  if(filled==TRUE) { #add a point at the center so the whole 'pie slice' is filled
    df <- rbind(df, center)
  }
  return(df)
}

# new version
ggplot(filter(get_FD.2sp, Type == "r"), aes(x = Sp_1, y = Sp_2, size = rich)) +
  # draw intrinsic growth rate vectors
  geom_segment(aes(x = 0, y = 0, xend = Sp_1, yend = Sp_2),
               arrow = arrow(length = unit(0.3,"cm"))) +
  # draw critical boundary
  #geom_segment(data = filter(get_FD.2sp, Type == "A")[1,], # just need one lower bound
  #             aes(x = 0, y = 0, xend = Sp_1, yend = Sp_2, linetype = "Critical\nboundary"),
  #             color = "black",
  #             size = 0.5) + 
  #scale_linetype_manual(values = "dotted", name = "") +
  xlab("Aphid growth rate (normalized)") + 
  ylab("Parasitoid growth rate (normalized)") +
  # illustrate circular nature of feasibility domain
  coord_cartesian(xlim = c(0,1), ylim = c(0.0,-0.75), expand = F) + 
  scale_size_manual(values = c(0.25,0.5,1), labels = c("1 genotype","2 genotypes","4 genotypes"), name = "") +
  # adjusted until critical boundary was correct
  geom_polygon(data=circleFun(c(0,0), diameter = 2, start=0, end=-0.191, npoints=100, filled=TRUE), 
               aes(x,y), alpha = 0.1, inherit.aes = F) +
  theme_cowplot(font_size = 18, line_size = 1)
ggsave("figures/rich-structural-stability-R-v2.pdf", width = 8, height = 8, units = "in") 
```

I then used Keynote to manually add images and text to create the final version presented in Figure 4 of the main text.

And just as a quick check, the above plot suggests that the community is only feasible (all three species have positive abundances at equilibrium) when there are 4 genotypes, which is true:

```{r}
-inv(rich1.mat)%*%rich1.IGR # Ptoid goes extinct
-inv(rich2.mat)%*%rich2.IGR # Ptoid goes extinct
-inv(rich4.mat)%*%rich4.IGR # Coexistence
```

## Non-equilibrium simulation (Fig. S6)

The above plot illustrates the effect of genetic diversity on the structural stability of the equilibrium abundances of species. I can explore whether our results hold in a non-equilibrium scenario that better characterizes our observational data.

To do this, I look at the the effect of genetic diversity across a range of initial conditions for the abundances of LYER and Ptoid. I get this data by simulating community dynamics with the observed effects of genetic diversity across a range of intial conditions. I restricted our simulation to 10 time steps, as BRBR went extinct commonly at week 7 (experiment was 17 weeks long). I also set an extinction threshold of log(abundance) = 1.

```{r nonequilibrium-sim}
LP_duration <- 10
LP_threshold <- 1 
res <- 0.1
LP_test_df <- expand.grid(LYER = seq(1, 6, by = res), Ptoid = seq(1, 6, by = res))

## simulate population dynamics and determine which species goes extinct

# rich = 1
FE_LP_rich1 <- list()
for(i in 1:length(LP_test_df$LYER)){
  FE_LP_rich1[[i]] <- first_extinction_2sp(Initial.States = c(LYER = LP_test_df[i,"LYER"], Ptoid = LP_test_df[i,"Ptoid"]), 
                                          Interaction.Matrix = rich1.mat + diag(2), 
                                          IGR.Vector = rich1.IGR, 
                                          Duration = LP_duration, 
                                          threshold = LP_threshold)
}
FE_LP_rich1_df <- bind_cols(LP_test_df, plyr::ldply(FE_LP_rich1)) %>%
  mutate(rich = 1)

# rich = 2
FE_LP_rich2 <- list()
for(i in 1:length(LP_test_df$LYER)){
  FE_LP_rich2[[i]] <- first_extinction_2sp(Initial.States = c(LYER = LP_test_df[i,"LYER"], Ptoid = LP_test_df[i,"Ptoid"]), 
                                           Interaction.Matrix = rich2.mat + diag(2), 
                                           IGR.Vector = rich2.IGR, 
                                           Duration = LP_duration, 
                                           threshold = LP_threshold)
}
FE_LP_rich2_df <- bind_cols(LP_test_df, plyr::ldply(FE_LP_rich2)) %>%
  mutate(rich = 2)

# rich = 4
FE_LP_rich4 <- list()
for(i in 1:length(LP_test_df$LYER)){
  FE_LP_rich4[[i]] <- first_extinction_2sp(Initial.States = c(LYER = LP_test_df[i,"LYER"], Ptoid = LP_test_df[i,"Ptoid"]), 
                                           Interaction.Matrix = rich4.mat + diag(2), 
                                           IGR.Vector = rich4.IGR, 
                                           Duration = LP_duration, 
                                           threshold = LP_threshold)
}
FE_LP_rich4_df <- bind_cols(LP_test_df, plyr::ldply(FE_LP_rich4)) %>%
  mutate(rich = 4)

# get observed data on initial abundances of LYER and Ptoid after BRBR went extinct
LP_actual_df <- timeseries_df %>%
  filter(BRBR_t == 0, LYER_t > 0, Ptoid_t > 0) %>%
  group_by(rich, Cage) %>%
  summarise_at(vars(LYER_t, Ptoid_t), list(first = first)) %>%
  ungroup() %>%
  mutate(rich = rich + 1, 
         log1p_LYER_t_first = log1p(LYER_t_first),
         log1p_Ptoid_t_first = log1p(Ptoid_t_first)) %>%
  as.data.frame()
```

The graph below shows a couple of useful things. First, our predictions hold for outside of equilibrium. That is, there is a greater likelihood of LYER-Ptoid persistence with increasing genetic diversity. Note the threshold between rich = 2 and rich = 4. This likely reflects the fact that the equilibrium community was only feasible when rich = 4.

It's also important to note that there is a region of parameter space where LYER goes extinct before Ptoid, which would eventually lead to the collapse of the Ptoid since it has lost its resource. This is not possible if I were to assume the community is at equilibrium. It also suggests that the likelihood of LYER going extinct before the Ptoid is more likely at lower levels of genetic diversity. I also observe this in our empirical data, as LYER going extinct before the Ptoid never occurred when rich = 4.

```{r nonequilibrium-plot, warning=FALSE}
cbPalette <-  viridis::viridis(4)

bind_rows(FE_LP_rich1_df, FE_LP_rich2_df, FE_LP_rich4_df) %>%
  mutate(rich = factor(rich, labels = c("1 genotype","2 genotypes","4 genotypes"))) %>%
  mutate(species = ifelse(is.na(species) == T, "Food chain persists", species),
         fspecies = factor(species, levels = c("LYER","Ptoid","Food chain persists"), labels = c("Complete collapse","Aphid only","Food chain persists"))) %>%
  ggplot(., aes(x = LYER, y = Ptoid, fill = fspecies)) +
  geom_tile() +
  facet_grid(~rich) +
  scale_fill_manual(name = "Critical transition", values = cbPalette[1:3]) + 
  coord_cartesian(xlim = c(1, max(LP_actual_df$log1p_LYER_t_first)), 
                  ylim = c(1, max(LP_actual_df$log1p_Ptoid_t_first))) +
  xlab("Aphid initial abundance (log scale)") +
  ylab("Parasitoid initial abundance (log scale)") +
  theme(strip.background = element_blank())
```

Remember though that our real communities are also stochastic, which is something I did not include in this non-equilibrium simulation. Below, I explicitly address stochasticity by estimating the uncertainty in our observed "mean" effects of genetic diversity on structural stability.

## Posterior estimates (Fig. S5)

The above is a nice visualization of the central tendency, but it doesn't illustrate the uncertainty in the effect of genetic richness on structural stability. To get at this, I need to use the posterior samples from our model.

```{r rich-posterior-stability}
# get posterior predictions
pp.rich_model <- posterior_samples(rich_model, pars = "^b")

# calculate structural stability when rich = 1
rich1_stability <- apply(
  pp.rich_model, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pLYERt1_log1pLYER_t"], x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pLYER_t"], 0), 
                     ncol = 2, byrow = TRUE)
    tmp.r = matrix(c(x["b_log1pLYERt1_intercept"],
                     x["b_log1pPtoidt1_intercept"] + x["b_log1pPtoidt1_temp"]*temp.cond),
                   ncol = 1)
    FeasibilityBoundaryLYER.Ptoid = as.numeric(BoundaryLYER.Ptoid(tmp.mat, tmp.r)["boundary"])
    c(FeasibilityBoundaryLYER.Ptoid = FeasibilityBoundaryLYER.Ptoid)
  })
rich1_stability.df <- data.frame(
  rich = 1,
  posterior_sample = 1:nrow(pp.rich_model),
  FeasibilityBoundaryLYER.Ptoid = rich1_stability
)

# calculate structural stability when rich = 2
rich2_stability <- apply(
  pp.rich_model, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pLYERt1_log1pLYER_t"], x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pLYER_t"], 0), 
                     ncol = 2, byrow = TRUE)
    tmp.r = matrix(c(x["b_log1pLYERt1_intercept"] + x["b_log1pLYERt1_rich"],
                     x["b_log1pPtoidt1_intercept"] +  x["b_log1pPtoidt1_rich"] + x["b_log1pPtoidt1_temp"]*temp.cond),  
                   ncol = 1)
    FeasibilityBoundaryLYER.Ptoid = as.numeric(BoundaryLYER.Ptoid(tmp.mat, tmp.r)["boundary"]) 
    c(FeasibilityBoundaryLYER.Ptoid = FeasibilityBoundaryLYER.Ptoid)
  })
rich2_stability.df <- data.frame(
  rich = 2,
  posterior_sample = 1:nrow(pp.rich_model),
  FeasibilityBoundaryLYER.Ptoid = rich2_stability
)

# calculate structural stability when rich = 4
rich4_stability <- apply(
  pp.rich_model, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pLYERt1_log1pLYER_t"], x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pLYER_t"], 0), 
                     ncol = 2, byrow = TRUE)
    tmp.r = matrix(c(x["b_log1pLYERt1_intercept"] + x["b_log1pLYERt1_rich"]*3,
                     x["b_log1pPtoidt1_intercept"] +  x["b_log1pPtoidt1_rich"]*3 + x["b_log1pPtoidt1_temp"]*temp.cond),  
                   ncol = 1)
    FeasibilityBoundaryLYER.Ptoid = as.numeric(BoundaryLYER.Ptoid(tmp.mat, tmp.r)["boundary"]) 
    c(FeasibilityBoundaryLYER.Ptoid = FeasibilityBoundaryLYER.Ptoid)
  })
rich4_stability.df <- data.frame(
  rich = 4,
  posterior_sample = 1:nrow(pp.rich_model),
  FeasibilityBoundaryLYER.Ptoid = rich4_stability
)

# combine data
all.rich_stability.df <- bind_rows(rich1_stability.df, rich2_stability.df, rich4_stability.df)
```

## Reproduce Fig. S5

```{r}
# subsample 1/8 of the posterior to make it easier to visualize
set.seed(38)
rsamp <- sample(1:8000, size = 1000)

# plot
all.rich_stability.df %>%
  filter(posterior_sample %in% rsamp) %>%
  ggplot(., aes(x = rich, y = FeasibilityBoundaryLYER.Ptoid)) +
  geom_line(aes(group = posterior_sample), alpha = 0.1) +
  stat_summary(fun.y = mean, geom = "line", color = "red") +
  theme_minimal_hgrid() +
  ylab("Normalized angle from critical boundary") +
  xlab("Genetic diversity (no. of genotypes)")
```

Calculate the percentage of posterior estimates where genetic diversity increased the structural stability of the community.

```{r}
# organize data
rich_LPbound <- all.rich_stability.df %>%
  select(rich, posterior_sample, FeasibilityBoundaryLYER.Ptoid) %>%
  spread(rich, FeasibilityBoundaryLYER.Ptoid) %>%
  mutate(rich_effect = `2` - `1`)

# calculate percentage
mean(rich_LPbound$rich_effect > 0)
```

## Genotypic effects

I first modify `rich_model` by replacing `rich` with `(Col + gsm1 + AOP2 + AOP2.gsoh)`, which are the components of the `rich` effect.

```{r genotype-mv-analysis}
## formulas
geno.rich_model.BRBR.bf <- reduced.3.BRBR.bf 
geno.rich_model.LYER.bf <- update(reduced.3.LYER.bf, .~. 
                                  -rich + (Col + gsm1 + AOP2 + AOP2.gsoh) 
                                  -log1p(BRBR_t):rich + log1p(BRBR_t):(Col + gsm1 + AOP2 + AOP2.gsoh))
geno.rich_model.Ptoid.bf <- update(reduced.3.Ptoid.bf, .~. 
                                  -rich + (Col + gsm1 + AOP2 + AOP2.gsoh) 
                                  -log1p(BRBR_t):rich + log1p(BRBR_t):(Col + gsm1 + AOP2 + AOP2.gsoh))

## fit new model
geno.rich_model.brm <- brm(
  data = full_df,
  mvbf(geno.rich_model.BRBR.bf, geno.rich_model.LYER.bf, geno.rich_model.Ptoid.bf),
  iter = 4000,
  prior = c(# growth rates
            set_prior(prior.r.BRBR, class = "b", coef = "intercept", resp = "log1pBRBRt1"),
            set_prior(prior.r.LYER, class = "b", coef = "intercept", resp = "log1pLYERt1"),
            set_prior(prior.r.Ptoid, class = "b", coef = "intercept", resp = "log1pPtoidt1"),
            # intraspecific effects
            set_prior(prior.intra.BRBR, class = "b", coef = "log1pBRBR_t", resp = "log1pBRBRt1"),
            set_prior(prior.intra.LYER, class = "b", coef = "log1pLYER_t", resp = "log1pLYERt1"),
            # negative interspecific effects
            set_prior(prior.BRBRonLYER, class = "b", coef = "log1pBRBR_t", resp = "log1pLYERt1"),
            set_prior(prior.PtoidonBRBR, class = "b", coef = "log1pPtoid_t", resp = "log1pBRBRt1"),
            set_prior(prior.PtoidonLYER, class = "b", coef = "log1pPtoid_t", resp = "log1pLYERt1"),
            # positive interspecific effects
            set_prior(prior.BRBRonPtoid, class = "b", coef = "log1pBRBR_t", resp = "log1pPtoidt1"),
            set_prior(prior.LYERonPtoid, class = "b", coef = "log1pLYER_t", resp = "log1pPtoidt1"),
            # rich effects
            set_prior(prior.rich, class = "b", coef = "Col", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:Col", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "gsm1", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:gsm1", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "AOP2", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:AOP2", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "AOP2.gsoh", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:AOP2.gsoh", resp = "log1pLYERt1"),
            set_prior(prior.rich, class = "b", coef = "Col", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:Col", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "gsm1", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:gsm1", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "AOP2", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:AOP2", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "AOP2.gsoh", resp = "log1pPtoidt1"),
            set_prior(prior.rich, class = "b", coef = "log1pBRBR_t:AOP2.gsoh", resp = "log1pPtoidt1"),
            # temp effects
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "temp", resp = "log1pPtoidt1"),  
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pBRBRt1"),
            set_prior(prior.temp, class = "b", coef = "log1pBRBR_t:temp", resp = "log1pPtoidt1"),
            set_prior(prior.temp, class = "b", coef = "log1pPtoid_t:temp", resp = "log1pBRBRt1"),
            # biomass effects
            set_prior(prior.AphidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pLYERt1"),
            set_prior(prior.PtoidBiomass, class = "b", coef = "logBiomass_g_t1", resp = "log1pPtoidt1"),
            # random effects
            set_prior(prior.random.effects, class = "sd", resp = "log1pBRBRt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pLYERt1"),
            set_prior(prior.random.effects, class = "sd", resp = "log1pPtoidt1")),
  file = "output/geno.rich_model.brm.rds") 

# print summary
summary(geno.rich_model.brm)
```

### Posterior estimates

```{r genotype-mv-posterior, warning=FALSE}
# get posterior predictions
pp.geno.rich_model.norm <- posterior_samples(geno.rich_model.brm, pars = "^b")

# intercept term corresponds to a hypothetical plant population where each genotype is absent
int.mv_stability <- apply(
  pp.geno.rich_model.norm, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pLYERt1_log1pLYER_t"], x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pLYER_t"], 0), 
                     ncol = 2, byrow = TRUE)
    tmp.r = matrix(c(x["b_log1pLYERt1_intercept"],
                     x["b_log1pPtoidt1_intercept"] + x["b_log1pPtoidt1_temp"]*temp.cond),
                   ncol = 1)
    FeasibilityBoundaryLYER.Ptoid = as.numeric(BoundaryLYER.Ptoid(tmp.mat, tmp.r)["boundary"]) 
    c(FeasibilityBoundaryLYER.Ptoid = FeasibilityBoundaryLYER.Ptoid)
  })
int.mv_stability.df <- data.frame(
  geno = "int",
  posterior_sample = 1:nrow(pp.geno.rich_model.norm),
  FeasibilityBoundaryLYER.Ptoid = int.mv_stability
)


# Col effect on structural stability
Col.mv_stability <- apply(
  pp.geno.rich_model.norm, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pLYERt1_log1pLYER_t"], x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pLYER_t"], 0),
                     ncol = 2, byrow = TRUE)
    tmp.r = matrix(c(x["b_log1pLYERt1_intercept"] + x["b_log1pLYERt1_Col"],
                     x["b_log1pPtoidt1_intercept"] + x["b_log1pPtoidt1_Col"] + x["b_log1pPtoidt1_temp"]*temp.cond),
                   ncol = 1)
    FeasibilityBoundaryLYER.Ptoid = as.numeric(BoundaryLYER.Ptoid(tmp.mat, tmp.r)["boundary"]) 
    c(FeasibilityBoundaryLYER.Ptoid = FeasibilityBoundaryLYER.Ptoid)
  })
Col.mv_stability.df <- data.frame(
  geno = "Col",
  posterior_sample = 1:nrow(pp.geno.rich_model.norm),
  FeasibilityBoundaryLYER.Ptoid = Col.mv_stability
)

# gsm1 effect on structural stability
gsm1.mv_stability <- apply(
  pp.geno.rich_model.norm, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pLYERt1_log1pLYER_t"], x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pLYER_t"], 0),
                     ncol = 2, byrow = TRUE)
    tmp.r = matrix(c(x["b_log1pLYERt1_intercept"] + x["b_log1pLYERt1_gsm1"],
                     x["b_log1pPtoidt1_intercept"] + x["b_log1pPtoidt1_gsm1"] + x["b_log1pPtoidt1_temp"]*temp.cond),
                   ncol = 1)
    FeasibilityBoundaryLYER.Ptoid = as.numeric(BoundaryLYER.Ptoid(tmp.mat, tmp.r)["boundary"]) 
    c(FeasibilityBoundaryLYER.Ptoid = FeasibilityBoundaryLYER.Ptoid)
  })
gsm1.mv_stability.df <- data.frame(
  geno = "gsm1",
  posterior_sample = 1:nrow(pp.geno.rich_model.norm),
  FeasibilityBoundaryLYER.Ptoid = gsm1.mv_stability
)

# AOP2 effect on structural stability
AOP2.mv_stability <- apply(
  pp.geno.rich_model.norm, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pLYERt1_log1pLYER_t"], x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pLYER_t"], 0),
                     ncol = 2, byrow = TRUE)
    tmp.r = matrix(c(x["b_log1pLYERt1_intercept"] + x["b_log1pLYERt1_AOP2"],
                     x["b_log1pPtoidt1_intercept"] + x["b_log1pPtoidt1_AOP2"] + x["b_log1pPtoidt1_temp"]*temp.cond),
                   ncol = 1)
    FeasibilityBoundaryLYER.Ptoid = as.numeric(BoundaryLYER.Ptoid(tmp.mat, tmp.r)["boundary"]) 
    c(FeasibilityBoundaryLYER.Ptoid = FeasibilityBoundaryLYER.Ptoid)
  })
AOP2.mv_stability.df <- data.frame(
  geno = "AOP2",
  posterior_sample = 1:nrow(pp.geno.rich_model.norm),
  FeasibilityBoundaryLYER.Ptoid = AOP2.mv_stability
)

# AOP2/gsoh effect on structural stability
AOP2.gsoh.mv_stability <- apply(
  pp.geno.rich_model.norm, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pLYERt1_log1pLYER_t"], x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pLYER_t"], 0),
                     ncol = 2, byrow = TRUE)
    tmp.r = matrix(c(x["b_log1pLYERt1_intercept"] + x["b_log1pLYERt1_AOP2.gsoh"],
                     x["b_log1pPtoidt1_intercept"] + x["b_log1pPtoidt1_AOP2.gsoh"] + x["b_log1pPtoidt1_temp"]*temp.cond),
                   ncol = 1)
    FeasibilityBoundaryLYER.Ptoid = as.numeric(BoundaryLYER.Ptoid((tmp.mat), tmp.r)["boundary"])
    c(FeasibilityBoundaryLYER.Ptoid = FeasibilityBoundaryLYER.Ptoid)
  })
AOP2.gsoh.mv_stability.df <- data.frame(
  geno = "AOP2.gsoh",
  posterior_sample = 1:nrow(pp.geno.rich_model.norm),
  FeasibilityBoundaryLYER.Ptoid = AOP2.gsoh.mv_stability
)

# combine data
all.geno.mv_stability.df <- bind_rows(
  int.mv_stability.df, 
  Col.mv_stability.df, 
  gsm1.mv_stability.df, 
  AOP2.mv_stability.df, 
  AOP2.gsoh.mv_stability.df)
```

### Reproduce Fig. S7

```{r plot-geno-structural-stability, warning=FALSE}
Col_df <- bind_rows(int.mv_stability.df, Col.mv_stability.df) %>% mutate(compare = "Col", geno = ifelse(geno == "int", 0, 1))
gsm1_df <- bind_rows(int.mv_stability.df, gsm1.mv_stability.df) %>% mutate(compare = "gsm1", geno = ifelse(geno == "int", 0, 1))
AOP2_df <- bind_rows(int.mv_stability.df, AOP2.mv_stability.df) %>% mutate(compare = "AOP2", geno = ifelse(geno == "int", 0, 1))
AOP2.gsoh_df <- bind_rows(int.mv_stability.df, AOP2.gsoh.mv_stability.df) %>% mutate(compare = "AOP2.gsoh", geno = ifelse(geno == "int", 0, 1))

bind_rows(Col_df, gsm1_df, AOP2_df, AOP2.gsoh_df) %>%
  filter(posterior_sample %in% rsamp) %>%
  mutate(compare = factor(compare, levels = c("Col","gsm1","AOP2","AOP2.gsoh"), labels = c("Col-0","gsm1","AOP2","AOP2/gsoh"))) %>%
  ggplot(., aes(x = geno, y = FeasibilityBoundaryLYER.Ptoid, color = compare)) +
  geom_line(aes(group = posterior_sample), alpha = 0.05) +
  stat_summary(fun.y = mean, geom = "line", size = 1.5) +
  facet_wrap(~compare, nrow = 1) +
  geom_hline(yintercept = 0, linetype = 'dotted') +
  ylab("Normalized angle from feasibility boundary") +
  scale_x_continuous(expand = c(0.1, 0.1), name = "", breaks = c(0,1), labels = c("Absent", "Present")) +
  scale_color_manual(values = c("darkgreen","steelblue","darkorange","firebrick1")) +
  theme_minimal_hgrid(font_size = 11) +
  theme(legend.position = "none")
```

I then calculate the percentage of posterior samples where each genotype increases the structural stability of the community.

```{r}
# gather data to calculate genotype-specific effects
geno_LPbound <- all.geno.mv_stability.df %>%
  select(geno, posterior_sample, FeasibilityBoundaryLYER.Ptoid) %>%
  spread(geno, FeasibilityBoundaryLYER.Ptoid) %>%
  mutate(Col_effect = (Col - int),
         gsm1_effect = (gsm1 - int),
         AOP2_effect = (AOP2 - int),
         AOP2.gsoh_effect = (AOP2.gsoh - int))

# effect of Col
mean(geno_LPbound$Col_effect > 0)

# effect of gsm1
mean(geno_LPbound$gsm1_effect > 0)

# effect of AOP2
mean(geno_LPbound$AOP2_effect > 0)

# effect of AOP2/gsoh
mean(geno_LPbound$AOP2.gsoh_effect > 0)
```


# Structural stability of initial food web

I use the same model as I did for the effect of genetic diversity `rich_model`. Note that there were other models that did as good of, if not better, a job at predicting the dynamics of the initial food web. However, it was only `reduced.3.brm` (now `rich_model`) that could also reproduce the genotype-specific effects (see \@ref{genotype-effects}).

```{r}
temp_model <- rich_model
```

## Reproduce Fig. S1

```{r}
coef.temp <- fixef(temp_model)[,"Estimate"]

# value of rich to condition
rich.cond <- 1.5 # 1.5 = 2.5 genotypes
# I chose 1.5, as with temp, to condition on
# an imaginary average between treatments
# note that setting it to zero, represents temp
# effect in plant monoculture

# interaction matrix when temp = 20 C
temp20.mat <- matrix(c(0, # constrained to biologically reasonable value of zero, rather than the positive estimate # coef.temp["log1pBRBRt1_log1pBRBR_t"],
                       0, 
                       coef.temp["log1pBRBRt1_log1pPtoid_t"],
                       coef.temp["log1pLYERt1_log1pBRBR_t"] + coef.temp["log1pLYERt1_log1pBRBR_t:rich"]*rich.cond,
                       coef.temp["log1pLYERt1_log1pLYER_t"],
                       coef.temp["log1pLYERt1_log1pPtoid_t"],
                       coef.temp["log1pPtoidt1_log1pBRBR_t"] + coef.temp["log1pPtoidt1_log1pBRBR_t:rich"]*rich.cond,
                       coef.temp["log1pPtoidt1_log1pLYER_t"], 
                       0),
                     ncol = 3, byrow = TRUE)

# growth rates when temp = 20 C
temp20.IGR <- matrix(c(coef.temp["log1pBRBRt1_intercept"],
                       coef.temp["log1pLYERt1_intercept"] + coef.temp["log1pLYERt1_rich"]*rich.cond,
                       coef.temp["log1pPtoidt1_intercept"] + coef.temp["log1pPtoidt1_rich"]*rich.cond),
                     ncol = 1)

# interaction matrix when temp = 23 C
temp23.mat <- matrix(c(coef.temp["log1pBRBRt1_log1pBRBR_t"] + coef.temp["log1pBRBRt1_log1pBRBR_t:temp"]*3, 
                       0, 
                       coef.temp["log1pBRBRt1_log1pPtoid_t"] + coef.temp["log1pBRBRt1_log1pPtoid_t:temp"]*3,
                       coef.temp["log1pLYERt1_log1pBRBR_t"] + coef.temp["log1pLYERt1_log1pBRBR_t:rich"]*rich.cond, 
                       coef.temp["log1pLYERt1_log1pLYER_t"], 
                       coef.temp["log1pLYERt1_log1pPtoid_t"],
                       0, # constrained to biologically reasonable value of zero, rather than negative estimate # coef.temp["log1pPtoidt1_log1pBRBR_t"] + coef.temp["log1pPtoidt1_log1pBRBR_t:rich"]*rich.cond + coef.temp["log1pPtoidt1_log1pBRBR_t:temp"]*3,
                       coef.temp["log1pPtoidt1_log1pLYER_t"], 
                       0),
                     ncol = 3, byrow = TRUE)

# growth rates when temp = 23 C
temp23.IGR <- matrix(c(coef.temp["log1pBRBRt1_intercept"] + coef.temp["log1pBRBRt1_temp"]*3,
                       coef.temp["log1pLYERt1_intercept"] + coef.temp["log1pLYERt1_rich"]*rich.cond,
                       coef.temp["log1pPtoidt1_intercept"] + coef.temp["log1pPtoidt1_rich"]*rich.cond + coef.temp["log1pPtoidt1_temp"]*3),
                     ncol = 1)

# assess feasibility
-1*inv(temp20.mat) %*% temp20.IGR # all species persist
-1*inv(temp23.mat) %*% temp23.IGR # BRBR goes extinct

# plot structural stability
constraints.matrix <- matrix(c(-1,0,0,
                               0,-1,0,
                               0,0,1),
                             ncol = 3, byrow = T)
PlotFeasibilityDomain3sp(A = list(temp20.mat, temp23.mat, constraints.matrix),
                         r = list(temp20.IGR, temp23.IGR, temp23.IGR), # IGR doesn't matter for constraints
                         A.color = c("steelblue","firebrick1","grey"),
                         r.color = c("steelblue","firebrick1","grey"),
                         normalize = TRUE,
                         sphere.alpha = 0,
                         arc.width = c(2,2,2),
                         barb.n = 2,
                         species.labels = c("B","L","P"))
# add axes
rgl.lines(x = c(0,1.1), y = c(0,0), z = c(0,0), color = "black", lwd = 3)
rgl.lines(x = c(0,0), y = c(1.1,0), z = c(0,0), color = "black", lwd = 3)
rgl.lines(x = c(0,0), y = c(0,0), z = c(-1.1,0), color = "black", lwd = 3)

# visualize in .html file
# note that I reproduce this visualization in `code/temperature-structural-stability-fig.R`
scene3d()
rglwidget()
```

From the above figure, it appears that the `L-P` boundary determines the feasibility of the community (`alpha.A23` below). Therefore, I focus on estimating the normalized angle of the intrinsic growth rate from this critical boundary.

```{r}
# calculate angle from critical boundary L-P for 23 C community
FeasibilityBoundary(temp23.mat, temp23.IGR)["alpha.A23"] 
```

```{r include=FALSE}
# B-L boundary
FeasibilityBoundary(temp23.mat, temp23.IGR)["alpha.A12"]
# B-P boundary
FeasibilityBoundary(temp23.mat, temp23.IGR)["alpha.A13"] # sign is incorrect. this means it's important to check manually check where the sign of the angle was correctly determined. Fortunately, this boundary doesn't determine feasibility.

## Explanation of Fig. S1
# This suggests that the change in the parasitoid's intrinsic growth rate, increasing with warmer temperatures accelerates the extinction of BRBR. This is because the only two things different about this boundary, from our data, is that the parasitoid's attack rate on BRBR actually decreased with warming. This acts to buffer extinction risk by expanding that part of the feasibility domain. However, the vector of intrinsic growth rate moves dramatically close to this boundary, suggesting the decrease in attack rate is insufficient to buffer the increase in intrinsic growth rate of the parasitoid.

#Note that the only difference for the `B-L` boundary which also constrains the feasibility domain is the increased intraspecific effects on BRBR. The expanded `B-P` boundary at 23 C is due to the now zero effect of BRBR on the Ptoid (it is positive at 20 C).
```


## Posterior estimates

```{r}
# get posterior predictions
pp.temp_model <- posterior_samples(temp_model, pars = "^b")
```

Inspect parameter estimates to ensure they are biologically reasonable.

```{r}
# some BRBR intrinsic growth rates became negative with warming
pp.temp_model %>%
  mutate(pp_ID = 1:nrow(.),
         r_BRBR_20 = b_log1pBRBRt1_intercept,
         r_BRBR_23 = b_log1pBRBRt1_intercept + b_log1pBRBRt1_temp*3) %>%
  select(pp_ID, r_BRBR_20, r_BRBR_23) %>%
  gather(key = temp, value = r, -pp_ID) %>%
  filter(pp_ID %in% rsamp) %>% # subsample to avoid crowding plot
  ggplot(., aes(x = temp, y = r)) +
  geom_line(aes(group = pp_ID), alpha = 0.1) +
  stat_summary(fun.y = mean, geom = "point", col = "red", size = 2) +
  geom_hline(yintercept = 0, linetype = "dotted", color = "red") 

# positive intraspecific interactions were sometimes estimated,
# even though this is biologically improbable
pp.temp_model %>%
  mutate(pp_ID = 1:nrow(.),
         intra_BRBR_20 = b_log1pBRBRt1_log1pBRBR_t,
         intra_BRBR_23 = b_log1pBRBRt1_log1pBRBR_t + `b_log1pBRBRt1_log1pBRBR_t:temp`*3) %>%
  select(pp_ID, intra_BRBR_20, intra_BRBR_23) %>%
  gather(key = temp, value = intra, -pp_ID) %>%
  filter(pp_ID %in% rsamp) %>% # subsample to avoid crowding plot
  ggplot(., aes(x = temp, y = intra)) +
  geom_line(aes(group = pp_ID), alpha = 0.1) +
  stat_summary(fun.y = mean, geom = "point", col = "red", size = 2) +
  geom_hline(yintercept = 0, linetype = "dotted", color = "red")

# the effect of BRBR on the parasitoid at warmer temperatures apparently
# was reduced to zero. Rather than setting it to zero, I used a more conservative
# approach, by constraining the lower bound to zero, allowing positive effects
# in the posterior samples.
pp.temp_model %>%
  mutate(pp_ID = 1:nrow(.),
         BRBR_Ptoid_20 = b_log1pPtoidt1_log1pBRBR_t,
         BRBR_Ptoid_23 = b_log1pPtoidt1_log1pBRBR_t + `b_log1pPtoidt1_log1pBRBR_t:temp`*3 + `b_log1pPtoidt1_log1pBRBR_t:rich`*rich.cond) %>%
  select(pp_ID, BRBR_Ptoid_20, BRBR_Ptoid_23) %>%
  gather(key = temp, value = inter, -pp_ID) %>%
  filter(pp_ID %in% rsamp) %>% # subsample to avoid crowding plot
  ggplot(., aes(x = temp, y = inter)) +
  geom_line(aes(group = pp_ID), alpha = 0.1) +
  stat_summary(fun.y = mean, geom = "point", col = "red", size = 2) +
  geom_hline(yintercept = 0, linetype = "dotted", color = "red")
  
# rarely is the parasitoid's intrinsic growth rate estimated as positive, 
# althought it should be negative
pp.temp_model %>%
  mutate(pp_ID = 1:nrow(.),
         r_BRBR_20 = b_log1pPtoidt1_intercept + b_log1pPtoidt1_rich*rich.cond,
         r_BRBR_23 = b_log1pPtoidt1_intercept + b_log1pPtoidt1_rich*rich.cond + b_log1pPtoidt1_temp*3) %>%
  select(pp_ID, r_BRBR_20, r_BRBR_23) %>%
  gather(key = temp, value = r, -pp_ID) %>%
  # use all samples to see occasional unrealistic estimate # filter(pp_ID %in% rsamp) %>% # subsample to avoid crowding plot
  ggplot(., aes(x = temp, y = r)) +
  geom_line(aes(group = pp_ID), alpha = 0.1) +
  stat_summary(fun.y = mean, geom = "point", col = "red", size = 2) +
  geom_hline(yintercept = 0, linetype = "dotted", color = "red") 
```

Note that some of the posterior samples can be biologically unfeasible, such as aphids with negative intrinsic growth rates. I restrict our inference to those parameters that are feasible. For example, if an aphid's intrinsic growth rate was estimated as negative, I manually set it to a small positive value of 0.1. In terms of the interactions, I ensured that any apparent negative effects of aphids on the parasitoids was unrealistic, so I constrained this parameter to be zero or positive.

Note that if I went ahead without this biological restriction, our results remain qualitatively the same. 

```{r warning=FALSE}
# get posterior samples of structural stability
temp20C_stability <- apply(
  pp.temp_model, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pBRBRt1_log1pBRBR_t"], 
                       0, 
                       x["b_log1pBRBRt1_log1pPtoid_t"],
                       x["b_log1pLYERt1_log1pBRBR_t"] + x["b_log1pLYERt1_log1pBRBR_t:rich"]*rich.cond, 
                       x["b_log1pLYERt1_log1pLYER_t"], 
                       x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pBRBR_t"] + x["b_log1pPtoidt1_log1pBRBR_t:rich"]*rich.cond, 
                       x["b_log1pPtoidt1_log1pLYER_t"], 
                       0),
                     ncol = 3, byrow = TRUE)
    # constrain intraspecific BRBR effect to a max of zero
    if(tmp.mat[1,1] > 0){
       tmp.mat[1,1] <- 0
    }
    # constrain BRBR-Ptoid interaction to a min of zero
    if(tmp.mat[3,1] < 0){
       tmp.mat[3,1] <- 0
    }
    
    tmp.r = matrix(c(x["b_log1pBRBRt1_intercept"],
                     x["b_log1pLYERt1_intercept"] + x["b_log1pLYERt1_rich"]*rich.cond,
                     x["b_log1pPtoidt1_intercept"] + x["b_log1pPtoidt1_rich"]*rich.cond),
                   ncol = 1)
    # constrain BRBR intrinsic growth rate to positive values
    if(tmp.r[1] < 0){
      tmp.r[1] <- 0.1 # small positive value
    }
    # constrain Ptoid intrinsic growth rate to negative values
    if(tmp.r[3] > 0){
      tmp.r[3] <- -0.1 # small negative value
    }
    
    Feasibility = as.numeric(FeasibilityBoundary(tmp.mat, tmp.r)["feasibility"])
    FeasibilityBoundary23 = as.numeric(FeasibilityBoundary(tmp.mat, tmp.r)["alpha.A23"])
    Extinctions = paste0(which(-1*inv(tmp.mat) %*% tmp.r < 0), collapse = ",")
    Resilience = max(Re(eigen((tmp.mat + diag(3)))$values))
    list(tmp.mat = tmp.mat,
         tmp.r = tmp.r,
         Feasibility = Feasibility,
         FeasibilityBoundary23 = FeasibilityBoundary23,
         Extinctions = Extinctions,
         Resilience = Resilience)
  })
temp20C_stability.df <- data.frame(
  temp = "20 C",
  posterior_sample = 1:nrow(pp.temp_model),
  Feasibility = unlist(lapply(temp20C_stability, FUN = function(x) x$Feasibility)),
  FeasibilityBoundary23 = unlist(lapply(temp20C_stability, FUN = function(x) x$FeasibilityBoundary23)),
  Extinctions = unlist(lapply(temp20C_stability, FUN = function(x) x$Extinctions)),
  Resilience = unlist(lapply(temp20C_stability, FUN = function(x) x$Resilience))
)

temp23C_stability <- apply(
  pp.temp_model, 
  MARGIN = 1, 
  FUN = function(x) { 
    tmp.mat = matrix(c(x["b_log1pBRBRt1_log1pBRBR_t"] + x["b_log1pBRBRt1_log1pBRBR_t:temp"]*3, 
                       0, 
                       x["b_log1pBRBRt1_log1pPtoid_t"] + x["b_log1pBRBRt1_log1pPtoid_t:temp"]*3,
                       x["b_log1pLYERt1_log1pBRBR_t"] + x["b_log1pLYERt1_log1pBRBR_t:rich"]*rich.cond, 
                       x["b_log1pLYERt1_log1pLYER_t"], 
                       x["b_log1pLYERt1_log1pPtoid_t"],
                       x["b_log1pPtoidt1_log1pBRBR_t"] + x["b_log1pPtoidt1_log1pBRBR_t:rich"]*rich.cond + x["b_log1pPtoidt1_log1pBRBR_t:temp"]*3, 
                       x["b_log1pPtoidt1_log1pLYER_t"], 
                       0),
                     ncol = 3, byrow = TRUE)
    # constrain intraspecific BRBR effect to a max of zero
    if(tmp.mat[1,1] > 0){
       tmp.mat[1,1] <- 0
    }
    # constrain BRBR-Ptoid interaction to a min of zero
    if(tmp.mat[3,1] < 0){
       tmp.mat[3,1] <- 0
    }
    
    tmp.r = matrix(c(x["b_log1pBRBRt1_intercept"] + x["b_log1pBRBRt1_temp"]*3,
                     x["b_log1pLYERt1_intercept"] + x["b_log1pLYERt1_rich"]*rich.cond,
                     x["b_log1pPtoidt1_intercept"] + x["b_log1pPtoidt1_rich"]*rich.cond + x["b_log1pPtoidt1_temp"]*3),
                   ncol = 1)
    # constrain BRBR intrinsic growth rate to positive values
    if(tmp.r[1] < 0){
      tmp.r[1] <- 0.1 # small positive value
    }
    # constrain Ptoid intrinsic growth rate to negative values
    if(tmp.r[3] > 0){
      tmp.r[3] <- -0.1 # small negative value
    }
    
    Feasibility = as.numeric(FeasibilityBoundary(tmp.mat, tmp.r)["feasibility"])
    FeasibilityBoundary23 = as.numeric(FeasibilityBoundary(tmp.mat, tmp.r)["alpha.A23"])
    Extinctions = paste0(which(-1*inv(tmp.mat) %*% tmp.r < 0), collapse = ",")
    Resilience = max(Re(eigen((tmp.mat + diag(3)))$values))
    list(tmp.mat = tmp.mat,
         tmp.r = tmp.r,
         Feasibility = Feasibility,
         FeasibilityBoundary23 = FeasibilityBoundary23,
         Extinctions = Extinctions,
         Resilience = Resilience)
  })
temp23C_stability.df <- data.frame(
  temp = "23 C",
  posterior_sample = 1:nrow(pp.temp_model),
  Feasibility = unlist(lapply(temp23C_stability, FUN = function(x) x$Feasibility)),
  FeasibilityBoundary23 = unlist(lapply(temp23C_stability, FUN = function(x) x$FeasibilityBoundary23)),
  Extinctions = unlist(lapply(temp23C_stability, FUN = function(x) x$Extinctions)),
  Resilience = unlist(lapply(temp23C_stability, FUN = function(x) x$Resilience))
)


all.temp_stability.df <- bind_rows(temp20C_stability.df, temp23C_stability.df) 
```

## Reproduce Fig. S2

```{r}
# Boundary determined by LYER-Ptoid (23)
all.temp_stability.df %>%
  filter(posterior_sample %in% rsamp) %>% # plot subset of posterior for easier visualization
  mutate(n.temp = as.numeric(as.factor(temp))) %>% 
  ggplot(., aes(x = n.temp, y = FeasibilityBoundary23)) +
  geom_line(aes(group = posterior_sample), alpha = 0.1) +
  stat_summary(fun.y = mean, geom = "line", color = "red", size = 1) +
  stat_summary(fun.y = mean, geom = "point", color = "red", size = 1.5) +
  theme_minimal_hgrid() +
  scale_x_continuous(name = "Temperature", breaks = c(1,2), labels = c("20 C", "23 C"), expand = c(0.1,0.1)) +
  ylab("Critical boundary (L-P)")

## calculate percentage of posterior estimates where temperature decreases structural stability
# organize data
FeasibilityBoundary23_df <- all.temp_stability.df %>%
  select(temp, posterior_sample, FeasibilityBoundary23) %>%
  spread(key = temp, value = FeasibilityBoundary23) %>%
  mutate(Diff = `23 C` - `20 C`)
# calculate percentage
mean(FeasibilityBoundary23_df$Diff < 0)
```

## Non-equilibrium simulation (Fig. S3)

```{r}
noneq_temp20 <- SimulateCommunityDynamics(IGR.Vector = temp20.IGR, Interaction.Matrix = (temp20.mat + diag(3)), Duration = 9) %>% mutate(temp = "20 C")

noneq_temp23 <- SimulateCommunityDynamics(IGR.Vector = temp23.IGR, Interaction.Matrix = (temp23.mat + diag(3)), Duration = 7) %>% mutate(temp = "23 C")

bind_rows(noneq_temp20, noneq_temp23) %>%
  gather(Species, value = "Abundance", -Week, - temp) %>%
  ggplot(., aes(x = Week, y = Abundance, color = Species)) +
  geom_hline(yintercept = 0, linetype = "dotted") +
  geom_line() +
  geom_point() +
  facet_wrap(~temp, ncol = 1) +
  theme_minimal_hgrid() +
  ylab("Abundance (log scale)") +
  scale_color_viridis_d(labels = c("B. brassicae","L. erysimi","D. rapae"))
```


# Save analysis 

Write out an `.RData` file to use for the Supplementary Online Materiak.

```{r}
save.image(file = "output/structural-stability.RData")
```
